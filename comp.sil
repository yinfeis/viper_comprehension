domain Array {
    // The slot function plays the role of mapping an array and integer index to the corresponding object.
  function loc(a: Array, i: Int): Ref
  function len(a: Array): Int
  function first(r: Ref): Array
  function second(r: Ref): Int

  // injective mapping
  axiom all_diff {
    forall a: Array, i: Int :: { loc(a,i) }
      first(loc(a,i)) == a && second(loc(a,i)) == i
  }

  axiom len_nonneg {
    forall a: Array :: { len(a) }
      len(a) >= 0
  }
}

field val: Int // field of values of the object
define access(a)
  (forall j: Int :: 0 <= j && j < len(a) ==> acc(loc(a,j).val))


/* 
 represents the sum of all elements in the array
 no body/postcondition
 */
function sum(a: Array) : Int
    requires access(a)


define incremented(a) sum(a) != old(sum(a))
// function incremented(a:Array) : Bool
//     requires access(a)
//     requires notincremented(a)

/* increments two to the value at position i in array a
 */
method incrementtwo(a: Array, i:Int) 
  requires access(a)
  requires 0 <= i && i < len(a)
  ensures  access(a)
  // ensures  incremented(a)
{
    var value : Int := loc(a,i).val
    loc(a,i).val := value + 2
}

/* swap the value at postion m and postion n in array a
 */
method swap(a: Array, m:Int, n:Int) 
  requires access(a)
  requires 0 <= m && m < len(a) && 0 <= n && n < len(a) && m != n
  ensures  access(a)
  // ensures  !incremented(a)
{
    var value : Int := loc(a,m).val
    loc(a,m).val := loc(a,n).val
    loc(a,n).val := value
}

// /* 
// reverse the array
//  */
// method reverse(a: Array) 
//   requires access(a)
//   ensures  access(a)
// {
//     var start: Int := 0
//     var end: Int := len(a)
//     while (start < end)
//       invariant access(a)
//       invariant 0 <= start && start <= end && end <= len(a)
//     {
//       var value : Int := loc(a,start).val
//       loc(a,start).val := loc(a,end).val
//       loc(a,end).val := value
//       start := start + 1
//       end := end - 1
//     }
// }

     
method client() {
  var a: Array
  // [0,1,2,3,4]
  inhale len(a) == 5
  inhale access(a)
  inhale forall i: Int :: 0 <= i && i < len(a) ==> loc(a, i).val == i
  var sum1 : Int := sum(a)
  //assert(sum(a) + 2 == sum(incrementtwo(a,2)))
  incrementtwo(a,2) // [0,1,4,3,4]
  var sum2 : Int := sum(a)
  // assert(sum1 != sum2)
  assert(incremented(a))
  
}